# Clustering Process Models #

After the unit chain has been executed, each process model owns a feature vector and is thus prepared for the actual clustering process. We implemented **hierarchical agglomerative clustering** in PromniCAT. We decided to use [WEKA](http://weka.wikispaces.com/Using+cluster+algorithms) as external library, since it comes along with implementations of hierarchical clusterers with Ward, Average, Single-Linkage etc. and also some distance functions (Edit, Manhattan Distance, etc). Nevertheless, these implementation do not fully suffice our demands. WEKA's hierarchical clusterer **does not support a normalization** of the numeric feature values, **considers no weights for the features** during the distance calculation, and **can only cluster numerical values**.

Since [WEKA](http://weka.wikispaces.com/Using+cluster+algorithms) uses customized data structures in their framework, we have to **map the output of the preprocessing step onto their structures** and have to **enhance them** to meet the formerly specified needs.

The normalization process takes only place **for all numeric feature values** and normalizes each feature value to the interval [0...1]. The maximum and minimum values of each feature are collected after retrieving the results from the unit chain by iterating over all feature vectors. To avoid another iteration over all feature vectors, the feature values retain their original values whilst performing the normalization in the distance calculation. This means that the distance function has to be adapted to incorporate normalization and take the maximum and minimum values. This is (up to now) done for the Euclidean Distance function by introducing the new class **WeightedEuclideanDistance** that inherits from WEKA's **EuclideanDistance** class.

This class, as well as **WeightedEditDistance**, also incorporates weighting of features. WEKA already supports weighting in their classifying functionalities via so-called **Attribute** classes, which can be reused for our purposes.

For anobject that is to be clustered, the numerical features are assigned to a variable containing the feature values in an array of doubles. Since this data structure has been specied by WEKA and thus can not be altered, the string feature values have to be hosted separately in another variable. Thus, we have to extend the existing classes to cope with a new attribute containing the string features in an array of strings. This strict division into string and numerical features includes an overall separate handling of these two different feature types: Creating, setting,and retrieving the feature values and calculating the distance between two feature vectors has to be implemented separately.

Whilst the realization of the former aspect is straightforward, the latter requires more efforts. This involves the usage of a further distance function in addition to the numeric one. By **applying two different distance functions for the comparison of two feature vectors**, their results again have to be combined to achieve a nal distance result. That is, the string distance function computes the overall distance of all string, the numeric distance function computes the distance for all numeric features.

The **output** of a clustering execution is a dendrogram of the clustered process models.The only output of clustering results provided by WEKA is a string representation in Newick
tree format. Nevertheless, the internal structure used by WEKA for clustering can be used as basis for a structure containing the actually clustered process models and their feature vectors. For that, we introduce the following tree structure:

![http://wiki.promnicat.googlecode.com/git/images/clustering_tree_class.png](http://wiki.promnicat.googlecode.com/git/images/clustering_tree_class.png)

The clusterer returns an instance of the class **ClusterTree**. It holds a reference to the root node of the tree and encapsulates further functionality for accessing and transforming the tree and its elements. The tree's nodes are instances of the class **ClusterNode**. Each node represents a cluster, again composed of the clusters their child nodes represent.